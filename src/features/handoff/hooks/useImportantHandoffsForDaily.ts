import { useEffect, useState } from 'react';
import type { HandoffDayScope, HandoffRecord } from '../handoffTypes';
import { useHandoffTimeline } from '../useHandoffTimeline';

/**
 * æ—¥æ¬¡è¨˜éŒ²ç”¨ã®é‡è¦ç”³ã—é€ã‚Šæƒ…å ±
 */
export interface ImportantHandoffForDaily {
  id: string | number;
  personId: string;
  personDisplayName: string;
  date: string;      // 'YYYY-MM-DD'
  time: string;      // 'HH:mm' æ™‚åˆ»è¡¨ç¤ºç”¨
  category: string;  // 'ä½“èª¿', 'è¡Œå‹•é¢', ...
  severity: 'é€šå¸¸' | 'è¦æ³¨æ„' | 'é‡è¦';
  message: string;
  timeBand: string;  // 'æœ', 'åˆå‰', 'åˆå¾Œ', 'å¤•æ–¹'
  status: string;    // 'æœªå¯¾å¿œ', 'å¯¾å¿œä¸­', 'å¯¾å¿œæ¸ˆ'
}

/**
 * æ—¥æ¬¡è¨˜éŒ²ä½œæˆæ™‚ã«é‡è¦ãªç”³ã—é€ã‚Šæƒ…å ±ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 *
 * @param personId å¯¾è±¡åˆ©ç”¨è€…ã®ID
 * @param date å¯¾è±¡æ—¥ä»˜ï¼ˆYYYY-MM-DDï¼‰
 * @returns é‡è¦åº¦ã€Œé‡è¦ã€ã®ç”³ã—é€ã‚Šã®ã¿
 */
export function useImportantHandoffsForDaily(personId: string, date: string) {
  const [importantHandoffs, setImportantHandoffs] = useState<ImportantHandoffForDaily[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // æ—¥ä»˜ã‹ã‚‰dayScopeã‚’æ±ºå®š
  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];

  let dayScope: HandoffDayScope = 'today';
  if (date === yesterday) {
    dayScope = 'yesterday';
  } else if (date !== today) {
    dayScope = 'week'; // éå»æ—¥ã¯é€±ã‚¹ã‚³ãƒ¼ãƒ—ã§å–å¾—
  }

  const {
    todayHandoffs: allHandoffs,
    loading: handoffsLoading,
    error: handoffsError
  } = useHandoffTimeline('all', dayScope);

  useEffect(() => {
    setLoading(handoffsLoading);
    setError(handoffsError);

    if (!handoffsLoading && !handoffsError && allHandoffs) {
      // æŒ‡å®šã•ã‚ŒãŸåˆ©ç”¨è€… + é‡è¦åº¦ã€Œé‡è¦ã€ã®ã¿ã‚’æŠ½å‡º
      const filtered = allHandoffs
        .filter(handoff => {
          // åˆ©ç”¨è€…IDãƒãƒƒãƒãƒ³ã‚°ï¼ˆuserCode ã¾ãŸã¯ personId ã§ç…§åˆï¼‰
          const userMatch = handoff.userCode === personId ||
                           handoff.userDisplayName.includes(personId);

          // é‡è¦åº¦ãƒ•ã‚£ãƒ«ã‚¿
          const severityMatch = handoff.severity === 'é‡è¦';

          return userMatch && severityMatch;
        })
        .map(handoff => convertToImportantHandoff(handoff));

      setImportantHandoffs(filtered);
    } else {
      setImportantHandoffs([]);
    }
  }, [personId, date, allHandoffs, handoffsLoading, handoffsError]);

  return {
    items: importantHandoffs,
    loading,
    error,
    count: importantHandoffs.length,
  };
}

/**
 * HandoffRecord ã‚’ ImportantHandoffForDaily ã«å¤‰æ›
 */
function convertToImportantHandoff(handoff: HandoffRecord): ImportantHandoffForDaily {
  // ä½œæˆæ™‚åˆ»ã‹ã‚‰æ™‚åˆ»æ–‡å­—åˆ—ã‚’ç”Ÿæˆ
  const createdAt = new Date(handoff.createdAt);
  const time = `${createdAt.getHours().toString().padStart(2, '0')}:${createdAt.getMinutes().toString().padStart(2, '0')}`;
  const date = createdAt.toISOString().split('T')[0]; // YYYY-MM-DD

  return {
    id: handoff.id,
    personId: handoff.userCode,
    personDisplayName: handoff.userDisplayName,
    date,
    time,
    category: handoff.category,
    severity: handoff.severity as 'é€šå¸¸' | 'è¦æ³¨æ„' | 'é‡è¦',
    message: handoff.message,
    timeBand: handoff.timeBand,
    status: handoff.status,
  };
}

/**
 * é‡è¦ãªç”³ã—é€ã‚Šã‹ã‚‰ç‰¹è¨˜äº‹é …ç”¨ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
 *
 * @param handoffs é‡è¦ãªç”³ã—é€ã‚Šãƒªã‚¹ãƒˆ
 * @param existing æ—¢å­˜ã®ç‰¹è¨˜äº‹é …ãƒ†ã‚­ã‚¹ãƒˆ
 * @returns æ•´å½¢ã•ã‚ŒãŸç‰¹è¨˜äº‹é …ãƒ†ã‚­ã‚¹ãƒˆ
 */
export function buildSpecialNotesFromImportantHandoffs(
  handoffs: ImportantHandoffForDaily[],
  existing = ''
): string {
  if (!handoffs || handoffs.length === 0) {
    return existing;
  }

  const header = 'ã€ç”³ã—é€ã‚Šï¼ˆé‡è¦ï¼‰ã‹ã‚‰è‡ªå‹•è»¢è¨˜ã€‘';

  // æ™‚åˆ»é †ã«ã‚½ãƒ¼ãƒˆï¼ˆå¤ã„é †ï¼‰
  const sortedHandoffs = [...handoffs].sort((a, b) => a.time.localeCompare(b.time));

  const lines = sortedHandoffs.map(handoff => {
    const statusIcon = getStatusIcon(handoff.status);
    const timePart = `${handoff.time}`;
    const categoryPart = handoff.category ? `${handoff.category}ï¼š` : '';

    return `ãƒ»${statusIcon} ${timePart} ${categoryPart}${handoff.message}`;
  });

  const autoGeneratedBlock = [header, ...lines].join('\n');

  // æ—¢å­˜ã®ç‰¹è¨˜äº‹é …ãŒã‚ã‚‹å ´åˆã¯ã€ä¸‹ã«è¿½åŠ 
  if (existing && existing.trim().length > 0) {
    return `${existing.trim()}\n\n${autoGeneratedBlock}`;
  }

  // ç©ºãªã‚‰ã€è‡ªå‹•ç”Ÿæˆãƒ–ãƒ­ãƒƒã‚¯ã®ã¿
  return autoGeneratedBlock;
}

/**
 * ç”³ã—é€ã‚Šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸã‚¢ã‚¤ã‚³ãƒ³ã‚’è¿”ã™
 */
function getStatusIcon(status: string): string {
  switch (status) {
    case 'æœªå¯¾å¿œ':
      return 'âš ï¸';
    case 'å¯¾å¿œä¸­':
      return 'ğŸ”„';
    case 'å¯¾å¿œæ¸ˆ':
      return 'âœ…';
    default:
      return 'ğŸ“';
  }
}

/**
 * ç”³ã—é€ã‚Šã‹ã‚‰ç‰¹è¨˜äº‹é …ã¸ã®è‡ªå‹•è»¢è¨˜ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
 */
export function shouldAutoGenerateSpecialNotes(
  isNewRecord: boolean,
  personId: string,
  currentSpecialNotes: string,
  importantHandoffsCount: number
): boolean {
  return (
    isNewRecord &&                                    // æ–°è¦ä½œæˆæ™‚ã®ã¿
    Boolean(personId) &&                             // åˆ©ç”¨è€…ãŒé¸æŠæ¸ˆã¿
    importantHandoffsCount > 0 &&                    // é‡è¦ãªç”³ã—é€ã‚ŠãŒå­˜åœ¨
    (!currentSpecialNotes || currentSpecialNotes.trim() === '')  // ç‰¹è¨˜äº‹é …ãŒç©º
  );
}

/**
 * è‡ªå‹•è»¢è¨˜ã•ã‚ŒãŸç‰¹è¨˜äº‹é …ã‹ã©ã†ã‹ã‚’åˆ¤å®š
 */
export function hasAutoGeneratedContent(text: string): boolean {
  return text.includes('ã€ç”³ã—é€ã‚Šï¼ˆé‡è¦ï¼‰ã‹ã‚‰è‡ªå‹•è»¢è¨˜ã€‘');
}

/**
 * è‡ªå‹•è»¢è¨˜éƒ¨åˆ†ã‚’é™¤å»ã—ã¦å…ƒã®ç‰¹è¨˜äº‹é …ã®ã¿ã‚’è¿”ã™
 */
export function removeAutoGeneratedContent(text: string): string {
  const headerIndex = text.indexOf('ã€ç”³ã—é€ã‚Šï¼ˆé‡è¦ï¼‰ã‹ã‚‰è‡ªå‹•è»¢è¨˜ã€‘');
  if (headerIndex === -1) {
    return text;
  }

  // ãƒ˜ãƒƒãƒ€ãƒ¼å‰ã®éƒ¨åˆ†ã®ã¿ã‚’è¿”ã™
  const beforeHeader = text.substring(0, headerIndex).trim();
  return beforeHeader;
}